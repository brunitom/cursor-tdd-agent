---
description:
  globs:
  alwaysApply: true
---

## Test Generation Guidance

### Scenario Authoring
- Use Given/When/Then for acceptance scenarios
- Keep assertions observable and user-facing where possible
- Avoid white-box coupling; prefer public APIs
 - Apply the Code-Agnostic Tests rule; prefer observable behavior and stable contracts

### Layer Selection Heuristics
- Unit: pure logic, edge cases, data validation
- Integration: DB, queues, framework boundaries
- Contract/E2E: API schemas, critical flows, cross-service contracts

### Data Strategy
- Deterministic fixtures and factories
- Minimal mocking; only at boundaries
- Seed data for end-to-end critical paths

### Technique Selection
- Read `memory-bank/assessment.md`, `riskMatrix.md`, `specSources.md`.
- Use diff buckets to choose techniques:
  - contracts/specs → Contract + Decision Tables
  - migrations/config → Smoke + rollback; Pairwise across env flags
  - core logic/validation → Boundary + Equivalence
  - stateful modules → State Transition
  - legacy touched → Characterization
- Output Test Matrix with [Must/Should/Could], mapping each scenario to a technique and observable.

### Spec Ingestion and Integration
- **Auto-discover specs** in `test-specs/` and project root: `.feature`, `.csv`, `.xml`, `.json`, `.md`, `.html`
- **Cross-reference** with `memory-bank/specSources.md` for existing mappings
- **Format-specific mapping**:
  - `.feature` scenarios → BDD/acceptance tests with Given/When/Then structure
  - `.csv` data sets → parameterized tests with equivalence partitioning
  - `.xml/.json` schemas → contract/API tests with schema validation
  - `.md` requirements → user story breakdown with acceptance criteria
  - `.html` mockups → UI integration tests with accessibility checks
- **Update** `memory-bank/specSources.md` with newly discovered specs
- **Trace requirements** from specs to test scenarios to implementation
- **Flag conflicts** between existing specs and new requirements

